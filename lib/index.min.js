'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var fs = _interopDefault(require('fs'));
var stringHash = _interopDefault(require('string-hash'));
var html = require('html5parser-fork');

function isDirectoryIgnore(directory) {
  // 如果目录在需要忽略的目录中，则不继续翻译此目录下的内容
  var ignoreDirectory = []; // 暂时不忽略任何目录

  var flag = false;

  for (var i = 0; i < ignoreDirectory.length; i++) {
    if (directory.indexOf(ignoreDirectory[i]) > -1) {
      flag = true;
      break;
    }
  }

  return flag;
} // 获取文件扩展名


function getExtendsion(filepath) {
  var index = filepath.lastIndexOf(".");
  var suffix = filepath.substr(index + 1);
  return suffix;
} // 给当前文件或文件夹添加完整的路径


function fullPath(dir, files) {
  return files.map(function (f) {
    return path.join(dir, f);
  });
}

function isFileExtensionInList(filepath, list) {
  var flag = false;

  if (!list.length) {
    return false;
  }

  for (var i = 0; i < list.length; i++) {
    if (filepath.indexOf(list[i]) > -1) {
      flag = true;
      break;
    }
  }

  return flag;
}

// 遍历目录，识别符合规则的文件

function readFileStr(file, callback) {
  // 这里读取当前文件全部内容，用来判断该文件的内容是否为空，如果为空的话lineReader.eachLine不会执行
  var str = fs.readFileSync(file).toString();
  return callback(file, str);
}

var fileextensions = ['.js', '.vue', '.html']; // 当前目录下js和html文件的总数

var filesize = 0; // 当前目录下已经完成读取的js和html文件的总数

var finishedSize = 0; // 当前目录下文件夹的数量

var directorySize = 0; // 当前目录下已经遍历的文件夹数量

var getDirectorySize = 0; // 当前目录下非js和html文件的总数

var otherFileSize = 0; // 当前目录下已经遍历的非js和html文件的数量

var getOtherFileSize = 0; // 存储所给目录下的所有文件夹

var directoryArr = [];
var callbackmapping = null;
var endCallback = null;

function mapDirectory(path, cbmapping, callback) {
  if (cbmapping) {
    callbackmapping = cbmapping;
  }

  if (callback) {
    endCallback = callback;
  }

  fs.readdir(path, function (err, files) {
    if (err) console.log(err);
    files = fullPath(path, files);

    if (files && files.length > 0) {
      // 循环获取当前目录下js和html文件、非这两种文件以及文件夹的数量
      for (var i = 0; i < files.length; i++) {
        var stats = fs.statSync(files[i]);

        if (stats.isFile()) {
          if (isFileExtensionInList(files[i], fileextensions)) {
            filesize++;
          } else {
            otherFileSize++;
          }
        }

        if (stats.isDirectory()) {
          if (!isDirectoryIgnore(files[i])) {
            directorySize++;
          }
        }
      }

      files.forEach(function (f) {
        fs.stat(f, function (err, stats) {
          if (stats.isFile()) {
            if (isFileExtensionInList(f, fileextensions)) {
              readFileStr(f, function (path, fileData) {
                // 回调处理
                callbackmapping(path, getExtendsion(path), fileData);
                finishedSize++;

                if (filesize == finishedSize) {
                  filesize = 0;
                  finishedSize = 0;
                  getOtherFileSize = 0;
                  otherFileSize = 0;
                  directorySize = 0;
                  getDirectorySize = 0;
                  var directory = directoryArr.shift();

                  if (directory) {
                    if (!isDirectoryIgnore(directory)) {
                      mapDirectory(directory);
                    }
                  } else {
                    // 结束了
                    console.log('目录遍历结束');
                    endCallback && endCallback();
                  }
                }
              });
            } else {
              readFileStr(f, function (path, fileData) {
                console.log('not Translate path:' + path);
              }); // 这里处理当前目录下即没有html、js文件也没有文件夹的情况

              if (filesize == 0 && directorySize == 0) {
                getOtherFileSize++;

                if (getOtherFileSize == otherFileSize) {
                  getOtherFileSize = 0;
                  otherFileSize = 0;
                  var directory = directoryArr.shift();

                  if (directory) {
                    if (!isDirectoryIgnore(directory)) {
                      mapDirectory(directory);
                    }
                  } else {
                    // writeTxt('../dest/final.txt', JSON.stringify(destDictionary));
                    // endCallback
                    console.log("====END====");
                    endCallback && endCallback();
                  }
                }
              }
            }
          }

          if (stats.isDirectory()) {
            if (!isDirectoryIgnore(f)) {
              directoryArr.push(f); // 这里处理当前目录下没有js和html文件的情况

              if (filesize == 0) {
                getDirectorySize++;

                if (getDirectorySize == directorySize) {
                  getDirectorySize = 0;
                  otherFileSize = 0;
                  getOtherFileSize = 0;
                  directorySize = 0;
                  var directory = directoryArr.shift();

                  if (directory) {
                    if (!isDirectoryIgnore(directory)) {
                      mapDirectory(directory);
                    }
                  }
                }
              }
            }
          }
        });
      });
    }
  });
}

function needtranslate(text, locale) {
  if (!locale) {
    locale = 'zh_cn';
  }

  locale = locale.toLowerCase().replace('-', '').replace('_', '');
  var testText = typeof str == 'string' ? text.trim() : text;

  switch (locale) {
    case 'zhcn':
      return /(.||\n)*[\u4e00-\u9fa5]+(.||\n)*$/.test(testText);

    case 'enus':
      return /a-zA-Z*/.test(text);
  }
}

// 判断属性值是否是vue绑定属性 :props="xxx" 和 v-bind:porps="xxx" @click v-model, v-show
function isVueBindAttr(text) {
  if (!text) {
    return false;
  }

  if (typeof str === "string") {
    text = text.trim();
  }

  return text.startsWith(':') || text.startsWith('v-bind:') || text.startsWith('v-') || text.startsWith('@');
}

var wordMapping = {};

// 传入中文，输出resourceId

function getResourceId(text) {
  var resouceId = 'YC_FED_' + stringHash(text);
  wordMapping[resouceId] = text.replace(/\n/g, ''); // .replace(/\s+/g, '')  有些是html代码片段，不能去掉空格

  return resouceId;
}

var __importDefault = (undefined && undefined.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (undefined && undefined.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = __importDefault(require("fs"));
var types = __importStar(require("ast-types"));
exports.types = types;
var parser_1 = require("./lib/parser");
exports.parse = parser_1.parse;
var printer_1 = require("./lib/printer");
/**
 * Traverse and potentially modify an abstract syntax tree using a
 * convenient visitor syntax:
 *
 *   recast.visit(ast, {
 *     names: [],
 *     visitIdentifier: function(path) {
 *       var node = path.value;
 *       this.visitor.names.push(node.name);
 *       this.traverse(path);
 *     }
 *   });
 */
var ast_types_1 = require("ast-types");
exports.visit = ast_types_1.visit;
/**
 * Reprint a modified syntax tree using as much of the original source
 * code as possible.
 */
function print(node, options) {
    return new printer_1.Printer(options).print(node);
}
exports.print = print;
/**
 * Print without attempting to reuse any original source code.
 */
function prettyPrint(node, options) {
    return new printer_1.Printer(options).printGenerically(node);
}
exports.prettyPrint = prettyPrint;
/**
 * Convenient command-line interface (see e.g. example/add-braces).
 */
function run(transformer, options) {
    return runFile(process.argv[2], transformer, options);
}
exports.run = run;
function runFile(path, transformer, options) {
    fs_1.default.readFile(path, "utf-8", function (err, code) {
        if (err) {
            console.error(err);
            return;
        }
        runString(code, transformer, options);
    });
}
function defaultWriteback(output) {
    process.stdout.write(output);
}
function runString(code, transformer, options) {
    var writeback = options && options.writeback || defaultWriteback;
    transformer(parser_1.parse(code, options), function (node) {
        writeback(print(node, options).code);
    });
}

var recast = /*#__PURE__*/Object.freeze({
  __proto__: null
});

var rule = function rule(expression) {
  // expression 分为left 和 right
  chooseRule(expression.left);
  chooseRule(expression.right, expression, 'right');
};

var rule$1 = function rule(Literal, parentNode, attrKey) {
  if (needtranslate(Literal.value)) {
    if (parentNode) {
      parentNode[attrKey] = generateCallExpression(getResourceId(Literal.value), Literal.value, globalData.quote);
    }
  }
};

var rule$2 = function rule(expression) {
  // expression 分为left 和 right
  expression.properties.forEach(function (prop) {
    chooseRule(prop.value, prop, 'value');
  });
};

var rule$3 = function rule(expression) {
  // expression 分为left 和 right
  expression.elements.forEach(function (el, index) {
    chooseRule(el, expression.elements, index);
  });
};

var rule$4 = function rule(expression) {
  // expression 分为left 和 right
  chooseRule(expression.body);
};

var rule$5 = function rule(statement) {
  // expression 分为left 和 right
  statement.body.forEach(function (state, index) {
    chooseRule(state, statement.body, index);
  }); // } catch (e) {
  //   console.log(print(statement).code)
  //   debugger
  // }
};

var rule$6 = function rule(expressionStatement) {
  chooseRule(expressionStatement.expression);
};

var rule$7 = function rule(expression) {
  expression.arguments.forEach(function (args, index) {
    chooseRule(args, expression.arguments, index);
  });
  chooseRule(expression.callee);
};

var rule$8 = function rule(expression) {
  expression.declarations.forEach(function (declaration, index) {
    declaration.init && chooseRule(declaration.init, declaration, "init");
  });
};

var rule$9 = function rule(expression) {
  expression.test && chooseRule(expression.test);
  expression.alternate && chooseRule(expression.alternate); // 一般是BlockStatement

  expression.consequent && chooseRule(expression.consequent); // 一般是BlockStatement、或者expression
};

var rule$a = function rule(expression) {
  // expression 分为left 和 right
  if (expression.argument) {
    chooseRule(expression.argument);
  }
};

var rule$b = function rule(statement) {
  // expression 分为left 和 right
  chooseRule(statement.right, statement, 'right');
};

var rule$c = function rule(expression) {
  chooseRule(expression.object);
  chooseRule(expression.property);
};

var rule$d = function rule(statement) {
  chooseRule(statement.left, statement, "left");
  chooseRule(statement.right, statement, "right");
};

var rule$e = function rule(expression) {
  chooseRule(expression.alternate, expression, "alternate");
  chooseRule(expression.consequent, expression, "consequent");
};

var rule$f = function rule(expression) {
  expression.cases.forEach(function (caseitem) {
    chooseRule(caseitem);
  });
};

var rule$g = function rule(expression) {
  chooseRule(expression.test, expression, 'test');
  expression.consequent.forEach(function (item) {
    chooseRule(item);
  });
};

var chooseRule = function chooseRule(expression, parentNode, attrKey) {
  // if (code.indexOf('data () {') >= 0) {
  //   console.log(code)
  //   debugger
  // }
  if (!expression.type) {
    console.log(JSON.stringify(expression));
    throw Error('expression.type should not be null');
  }

  switch (expression.type) {
    case 'SwitchStatement':
      rule$f(expression);
      break;
    // switch () case

    case 'SwitchCase':
      rule$g(expression);
      break;

    case 'ConditionalExpression':
      rule$e(expression);
      break;
    // a ? 1 : 2

    case 'BinaryExpression':
      rule$d(expression);
      break;
    // a == b

    case 'LogicalExpression':
      rule(expression);
      break;
    // a || b

    case 'Identifier':
      break;
    // var a

    case 'Literal':
      rule$1(expression, parentNode, attrKey);
      break;
    // "test"

    case 'ObjectExpression':
      rule$2(expression);
      break;
    //{a:1,b:2}

    case 'ArrayExpression':
      rule$3(expression);
      break;
    // [1,2,3,4]

    case 'FunctionExpression':
      rule$4(expression);
      break;
    // function () {}

    case 'BlockStatement':
      rule$5(expression);
      break;
    // return {xxxxx};

    case 'ReturnStatement':
      rule$a(expression);
      break;
    //chooseRule(expression.argument); break; // 同上

    case 'ExpressionStatement':
      rule$6(expression);
      break;
    // this.xx = 'test'

    case 'CallExpression':
      rule$7(expression);
      break;
    // cb("a", "中文")

    case 'VariableDeclaration':
      rule$8(expression);
      break;
    // var a

    case 'IfStatement':
      rule$9(expression);
      break;
    // if (a == "中文")

    case 'AssignmentExpression':
      rule$b(expression);
      break;
    // a = "test"

    case 'MemberExpression':
      rule$c(expression);
      break;
    // console.log

    case 'ThisExpression':
      break;
    // this

    case 'BreakStatement':
      break;

    case 'UnaryExpression':
      break;

    default:
      console.log("notexist:" + expression.type);
  }
};

/**
 * 解析纯javascript代码
 * 
 * @param {*} node 
 */

var rule$h = function rule(input, quote) {
  globalData.quote = quote;
  var ast = undefined(input); // see more details in https://github.com/benjamn/ast-types/blob/master/gen/visitor.ts

  undefined(ast, {
    // vue节点 有时候直接以export default开头
    visitExportDefaultDeclaration: function visitExportDefaultDeclaration(path) {
      var node = path.node;
      chooseRule(node.declaration, quote, null);
      return false;
    },
    // visitStatement
    visitStatement: function visitStatement(path) {
      // BinaryExpression  'a'+'b'
      var node = path.node;
      var output = undefined(node).code;

      if (needtranslate(output)) ;

      chooseRule(node, quote);
      return false;
    },
    // 便利属性定义 var b = 'test'
    visitIdentifier: function visitIdentifier(path) {
      var node = path.node;
      var output = undefined(node).code;

      if (needtranslate(output)) {
        console.log('visitIdentifier:', output);
      }

      return false;
    },
    visitExpressionStatement: function visitExpressionStatement(path) {
      var node = path.node; // 判断参数里是否包含call和literal

      var output = undefined(node).code;

      if (needtranslate(output)) ;

      try {
        chooseRule(node.expression, quote, null, null);
      } catch (e) {
        debugger;
      }

      return false;
    }
  });
  globalData.quote = null;
  return undefined(ast).code;
};

var koAttrReast = function koAttrReast(koTagNode) {
  var _koTagNode$value;

  var varStr = "var a = "; //拼凑为reast可识别的结构

  var value = ((_koTagNode$value = koTagNode.value) === null || _koTagNode$value === void 0 ? void 0 : _koTagNode$value.value) ? koTagNode.value.value : koTagNode.value;
  var hasBrackets = value.trim()[0] === "{";

  if (hasBrackets) {
    //data-bind="text:xxx,html:xxx" => data-bind="{text:xxx,html:xxx}"
    value = varStr + value;
  } else {
    value = "".concat(varStr, "{").concat(value, "}");
  }

  var str = "";
  var attrStr = "";
  var recastNode = undefined(value);
  var array = recastNode.tokens;
  var startIndex = 0; //attr:{xy:123}是{的下标

  var endIndex = 0; //attr:{xy:123}是}的下标

  for (var i = 0; i < array.length; i++) {
    var ele = array[i];

    if (ele.value === "{" && array[i - 2].value === "attr") {
      startIndex = i;
      break;
    }

    if (i == 1 || i == 2) {
      //保持变量空格 与varStr一致
      str += " ".concat(ele.value);
    } else {
      str += ele.value;
    }
  }

  if (startIndex == 0) {
    //data-bind里面没有attr
    str = str.slice(0, -1); //koTagNode.nativeAttrs格式['placeholer:xxx',title:'xxx',xxx:'xxx']数组

    if (koTagNode.nativeAttrs) {
      str += ",attr:{";
    }

    koTagNode.nativeAttrs && koTagNode.nativeAttrs.forEach(function (item) {
      str += item;
    });

    if (koTagNode.nativeAttrs) {
      str += "}";
    }

    str += '}';
  } else {
    var reduceNum = 0;

    for (var _i = startIndex; _i < array.length; _i++) {
      var _ele = array[_i];

      if (_ele.value === "{" && _ele.type === "Punctuator") {
        reduceNum += 1;
      }

      if (_ele.value === "}" && _ele.type === "Punctuator") {
        reduceNum -= 1;
      }

      attrStr += _ele.value; //拼接字符串

      if (reduceNum === 0) {
        endIndex = _i;
        break;
      }
    }

    var attrValueStr = attrStr.slice(1, -1); //去掉前后括号

    koTagNode.nativeAttrs && koTagNode.nativeAttrs.forEach(function (item) {
      attrValueStr += ",".concat(item);
    });
    str += '{' + attrValueStr + '}';
  }

  if (startIndex > 0 && endIndex < array.length - 1) {
    for (var _i2 = endIndex + 1; _i2 < array.length; _i2++) {
      var _ele2 = array[_i2];
      str += _ele2.value;
    }
  }

  var reastStr = rule$h(str);
  reastStr = reastStr.slice(varStr.length - 1);

  if (!hasBrackets) {
    reastStr = reastStr.slice(1, -1);
  }

  return reastStr;
};

var _recast$types$builder = undefined,
    id = _recast$types$builder.identifier,
    callExpression = _recast$types$builder.callExpression,
    literal = _recast$types$builder.literal,
    memberExpression = _recast$types$builder.memberExpression,
    commentBlock = _recast$types$builder.commentBlock; // 传入资源id 生成：cb.lang.template("${ resid }")格式的语法

function generateCallExpression(resid, originText, quote) {
  // 文本添加注释
  var comment = commentBlock(originText, false, true);
  var text = literal.from({
    value: resid,
    comments: [comment]
  }); // 生成cb.lang.template('text'/* text */)的形式

  var expression = callExpression(memberExpression(memberExpression(id('cb'), id('lang')), id('template')), [text]);

  if (quote && quote !== "'") {
    var code = undefined(expression).code;
    code = code.replace(/"/g, "'");
    return undefined(code);
  } else {
    return expression;
  }
}

// 判断是不是包含{{
function isDynamicText(text) {
  if (!text) {
    return false;
  }

  var result = false;

  try {
    result = text.indexOf("{{") >= 0 || text.indexOf("{ {") >= 0;
  } catch (e) {
    debugger;
  }

  return result;
}

function mkdirPath(pathStr) {
  var projectPath = path.join(process.cwd());

  if (pathStr.indexOf('/') == 0) {
    projectPath = "";
  }

  var tempDirArray = pathStr.indexOf('\\') >= 0 ? pathStr.split('\\') : pathStr.split('\/');

  for (var i = 0; i < tempDirArray.length - 1; i++) {
    projectPath = projectPath + '/' + tempDirArray[i];

    if (fs.existsSync(projectPath)) {
      var tempstats = fs.statSync(projectPath);

      if (!tempstats.isDirectory()) {
        fs.unlinkSync(projectPath);
        fs.mkdirSync(projectPath);
      }
    } else {
      fs.mkdirSync(projectPath);
    }
  }

  return projectPath;
}

function writeFile(path, stringData) {
  mkdirPath(path);
  fs.writeFile(path, stringData, function (err) {
    if (err) {
      debugger;
      throw err;
    }

    console.log(path + ' has been saved!');
  });
}

var globalData = {
  quote: null
};

var TRANSLATE_METHOD = 'cb.lang.template';

function ast2String(ast, text) {
  if (!text) {
    text = '';
  }

  ast.forEach(function (item) {
    if (item.type === html.SyntaxKind.Text) {
      text += item.value;
    } else if (item.type === html.SyntaxKind.Tag) {
      if (item.name === "!--") {
        //<!-- ko text:xxx --><!-- /ko -->
        text += item.open.value + item.body[0].value + item.close.value;
      } else {
        text += '<' + item.name;
        item.attributes && item.attributes.forEach(function (attr, index) {
          var splitChar = " ";

          if (attr.value) {
            // 可能存在没有引号的情况
            if (!attr.value.quote) {
              attr.value.quote = "";
            }

            text += splitChar + attr.name.value + '=' + attr.value.quote + attr.value.value + attr.value.quote;
          } else {
            text += splitChar + attr.name.value;
          }
        });

        if (item.name.toLowerCase() == '!doctype') {
          text += ' html';
        }

        text += '>';

        if (item.body) {
          text = ast2String(item.body, text);
        }

        if (item.close) {
          text += item.close.value;
        }
      }
    }
  });
  return text;
}

var scriptrules = [];

var tagrules = [];

var textrules = [];

var isInScript = false;
/**
 * 
 * @param {*} input 
 * @param {
 *  tagEnter: Function, 
 *  scriptEnter: Function,
 *  textEnter: Function,
 *  leave: Function
 * } option 
 */

function init(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ast = html.parse(input);
  var tagRule = options.tagRule,
      scriptRule = options.scriptRule,
      textRule = options.textRule,
      leave = options.leave;
  html.walk(ast, {
    enter: function enter(node) {
      if (node.type === html.SyntaxKind.Tag) {
        var _node$open;

        if (node.name == "script") {
          isInScript = true;
        }

        if (node.name === "!--") {
          node.body[0]._isComment = true;
        } // node.open.value是tag的string值, 注释需要进行处理翻译


        if (needtranslate(node === null || node === void 0 ? void 0 : (_node$open = node.open) === null || _node$open === void 0 ? void 0 : _node$open.value)) {
          // 默认规则
          tagrules.forEach(function (rule) {
            if (!node._translated) {
              rule(node);
            }
          }); // 自定义规则

          tagRule && tagRule.forEach(function (rule) {
            if (!node._translated) rule(node);
          });
        }
      } else {
        // html中解析内部js
        if (isInScript) {
          var jsast = undefined(node.value); // 默认规则

          scriptrules.forEach(function (rule) {
            rule(jsast);
          }); // 自定义规则

          scriptRule && scriptRule.forEach(function (rule) {
            rule(jsast);
          }); // js转换后重新解析

          var output = undefined(jsast).code;
          node.value = output;
        }

        if (needtranslate(node === null || node === void 0 ? void 0 : node.value)) {
          textrules.forEach(function (rule) {
            if (!node._translated) rule(node);
          }); // 自定义规则

          textRule && textRule.forEach(function (rule) {
            if (!node._translated) rule(node);
          });
        }
      }
    },
    leave: function leave(node) {
      if (isInScript) {
        isInScript = false;
      }
    }
  });
  return ast;
}

/**
 * 比如 placeholder
 * 等这种纯html属性 以及自定义组件 不包含:以及v-bindv-bind
 * <group title="我的真实姓名：" class="form-group">
 * <group :title="cb.lang.template('resid'/*我的真实姓名：/*)" class="form-group">
 * @param {*} node 
 */

var rule$i = function rule(node) {
  if (node.attributes) {
    node.attributes.forEach(function (v) {
      var _v$name, _v$value, _v$value2;

      if (!isVueBindAttr((_v$name = v.name) === null || _v$name === void 0 ? void 0 : _v$name.value) && needtranslate((_v$value = v.value) === null || _v$value === void 0 ? void 0 : _v$value.value) && !((_v$value2 = v.value) === null || _v$value2 === void 0 ? void 0 : _v$value2._translated)) {
        var _v$value3, _v$value4;

        v.name.value = ':' + v.name.value;
        var quote = v.value.quote == '"' ? "'" : '"';
        v.value.value = TRANSLATE_METHOD + '(' + quote + getResourceId((_v$value3 = v.value) === null || _v$value3 === void 0 ? void 0 : _v$value3.value) + quote + '/*' + ((_v$value4 = v.value) === null || _v$value4 === void 0 ? void 0 : _v$value4.value) + '*/)';
        v.value._translated = true;
      }
    });
  }
};

/**
 * 比如 placeholder
 * 等这种纯html属性 以及自定义组件
 * 输入文本：中文
 * 注意 Text可能是 {{'a'|| b}} 这种要用js来处理要区分开来
 * @param {*} node 
 */

var rule$j = function rule(node) {
  if (node.type == "Text" && !node._translated) {
    node._translated = true;
    var originText = node.value.trim();
    var quote = '"';
    node.value = "{{" + TRANSLATE_METHOD + '(' + quote + getResourceId(originText) + quote + '/*' + originText + '*/)' + "}}";
  }
};

/**
 * 比如 placeholder
 * 等这种纯html属性 以及自定义组件 不包含:以及v-bindv-bind
 * <group title="我的真实姓名：" class="form-group">
 * <group :title="cb.lang.template('resid'/*我的真实姓名：/*)" class="form-group">
 * @param {*} node 
 */

var rule$k = function rule(node) {
  if (node.attributes) {
    node.attributes.forEach(function (v) {
      var _v$name, _v$value;

      if (isVueBindAttr((_v$name = v.name) === null || _v$name === void 0 ? void 0 : _v$name.value) && !((_v$value = v.value) === null || _v$value === void 0 ? void 0 : _v$value._translated)) {
        var _v$value2;

        if (needtranslate((_v$value2 = v.value) === null || _v$value2 === void 0 ? void 0 : _v$value2.value)) {
          var _v$value3;

          // 可能会出现纯字符串，非正规js语句 转成 var aaa = 之后再替换掉
          var text = (_v$value3 = v.value) === null || _v$value3 === void 0 ? void 0 : _v$value3.value;
          var convertString = rule$h("var aaa =" + text, v.value.quote);
          convertString = convertString.replace("var aaa =", "");
          v.value._translated = true;
          v.value.value = convertString;
        }
      }
    });
  }
};

/**
 * Text里需要用js解析的 模版
 * 如：{{a||'中文'}}
 */

var rule$l = function rule(node) {
  if (isDynamicText(node.value)) {
    node._translated = true;
    var originText = node.value.trim(); // 有可能是 aa {{a}}aa{{a}}的形式，所要要把text和{{}}包含的内容拆开来解析
    // 现根据 {{ 拆分成字符串，然后不包含}}的则为要用js解析的字符串，没有}}的 认为直接按字符串来处理
    // TODO:  继续完善

    var LEFT = "{{";
    var RIGHT = "}}";
    var splitResult = originText.split(LEFT);
    var rawTexts = [];
    var dynamicTexts = [];
    splitResult.forEach(function (r, index) {
      if (r) {
        if (r.indexOf(RIGHT) >= 0) {
          r.split(RIGHT).forEach(function (t, innerindex) {
            if (innerindex === 0) {
              dynamicTexts.push({
                index: index - 0.1,
                text: t
              });
            } else {
              rawTexts.push({
                index: index,
                text: t
              });
            }
          });
        } else {
          rawTexts.push({
            index: index,
            text: r
          });
        }
      }
    });
    var quote = '"';
    rawTexts = rawTexts.map(function (text) {
      var translate = text.text;

      if (needtranslate(translate)) {
        translate = "{{" + TRANSLATE_METHOD + '(' + quote + getResourceId(text.text) + quote + '/*' + text.text + '*/)' + "}}";
      }

      return {
        index: text.index,
        text: translate
      };
    });
    dynamicTexts = dynamicTexts.map(function (text) {
      var translate = text.text;

      if (needtranslate(translate)) {
        translate = rule$h(translate);
      }

      translate = "{{" + translate + "}}";
      return {
        index: text.index,
        text: translate
      };
    });
    var translatedText = [].concat(rawTexts).concat(dynamicTexts).sort(function (a, b) {
      return a.index - b.index;
    }) // 按index排序
    .map(function (i) {
      return i.text;
    }) // 只保留翻译后的text
    .reduce(function (a, b) {
      return a + b;
    }); // 拼接所有text

    node.value = translatedText;
  }
};

/**
 * <!-- test -->
 * @param {*} node 
 */
// {{cb.template.lang('xxxid'/*中文*/)}}
var rule$m = function rule(node) {
  if (node.type == "Text" && !node._translated && node._isComment) {
    node._translated = true;
  }
};

var rules = {
  vueTagRule: [rule$i, rule$k],
  vueTextRule: [rule$m, rule$l, rule$j]
};

var rule$n = function rule(node) {
  /**
   * 首先，判断是否有原生属性
   *    有原生属-->
   *        判断有没有data-bind
   *            有data-bind --> 
   *                判断有没有attr-->
   *                  有attr-->找到下标添加字符
   *                  没有attr-->添加attr:{}
   *            没有data-bind
   *                直接添加data-bind:attr
   *    没有原生属性，直接替换data-bind里面的汉字
   */
  if (Array.isArray(node.nativeAttrs)) {
    //只有data-bind才会有普通属性，params,options
    var dataBindAttr = node.attributes.filter(function (attr, index) {
      return attr.name.value === "data-bind";
    })[0];

    if (dataBindAttr) {
      dataBindAttr.nativeAttrs = node.nativeAttrs;
      dataBindAttr.value.value = koAttrReast(dataBindAttr);
    } else {
      //没有data-bind
      var attrs = node.nativeAttrs;
      var value = "attr:{";
      attrs.forEach(function (v) {
        value += "".concat(v, ",");
      });
      value = value.slice(0, -1);
      node.attributes.push({
        value: {
          value: value + "}",
          quote: "'"
        },
        name: {
          value: "data-bind"
        }
      });
      node.attributes.forEach(function (v) {
        var _v$value;

        if ((v === null || v === void 0 ? void 0 : v.name.value) === "data-bind" && needtranslate((_v$value = v.value) === null || _v$value === void 0 ? void 0 : _v$value.value)) {
          v.value.value = koAttrReast(v);
        }
      });
    }
  } else {
    node.attributes.forEach(function (v) {
      var _v$value2;

      if (((v === null || v === void 0 ? void 0 : v.name.value) === "data-bind" || (v === null || v === void 0 ? void 0 : v.name.value) === "params" || (v === null || v === void 0 ? void 0 : v.name.value) === "options") && needtranslate((_v$value2 = v.value) === null || _v$value2 === void 0 ? void 0 : _v$value2.value)) {
        v.value.value = koAttrReast(v);
      }
    });
  }
};

var rule$o = function rule(node) {
  var cache = [];
  var filterAttrs = [];
  node.attributes.forEach(function (v) {
    var nativeAttrs = ['title', 'placeholder', 'value'];

    var _index = nativeAttrs.indexOf(v.name.value);

    if (_index >= 0 && needtranslate(v.value.value)) {
      filterAttrs.push(nativeAttrs[_index]);
      var quote = v.value.quote === "'" ? '"' : "'";
      cache.push("".concat(nativeAttrs[_index], ":").concat(quote).concat(v.value.value).concat(quote)); // cache.push({
      //   key:nativeAttrs[_index],
      //   name:`${quote}${v.value.value}${quote}`
      // })

      node.nativeAttrs = cache;
    }
  });
  node.attributes = node.attributes.filter(function (v) {
    return filterAttrs.indexOf(v.name.value) < 0;
  });
};

var rule$p = function rule(node) {
  if (node._isComment) {
    if (/[\s]*ko[\s]+/.test(node.value)) {
      node.value = node.value.replace(/[\s]*ko[\s]+/, "");
      node.value = koAttrReast(node);
      node.value = " ko " + node.value;
    }
  } else {
    node.value = "<!-- ko text: ".concat(TRANSLATE_METHOD, "('").concat(getResourceId(node.value), "'/*").concat(node.value, "*/)--><!-- /ko -->");
  }
};

var rule$q = {
  koTagRule: [rule$o, rule$n],
  koTextRule: [rule$p]
};

var htmlrules = {
  vueTagRule: rules.vueTagRule,
  vueTextRule: rules.vueTextRule,
  koTagRule: rule$q.koTagRule,
  koTextRule: rule$q.koTextRule
};

// 把.vue文件拆分成template、script和style
var vueTagRule = htmlrules.vueTagRule,
    vueTextRule = htmlrules.vueTextRule;

var init$1 = function init$1(input) {
  var ast = html.parse(input);
  var templateNode = null;
  var scriptNode = null;
  var styleNode = null;
  templateNode = ast.filter(function (node) {
    return node.name == "template";
  });
  scriptNode = ast.filter(function (node) {
    return node.name == "script";
  });
  styleNode = ast.filter(function (node) {
    return node.name == "style";
  });
  var templateAst = init(ast2String(templateNode), {
    tagRule: vueTagRule,
    textRule: vueTextRule
  }); // ast => string

  var strTemplate = ast2String(templateAst); // script => string

  var strScript = rule$h(scriptNode[0].body[0].value);
  return strTemplate + "\n" + "<script>" + strScript + "</script>" + "\n" + ast2String(styleNode);
};

var vueTagRule$1 = htmlrules.vueTagRule,
    vueTextRule$1 = htmlrules.vueTextRule;

var translate = function translate(configPath) {
  var config = require(configPath || path.join(__dirname, "./i18nparser.config.js"));

  var sourcePath = config.sourcePath,
      outputPath = config.outputPath,
      needTranslate = config.needTranslate,
      type = config.type;
  var extractOnly = false;

  function output(filepath, strFileData) {
    if (!extractOnly) {
      filepath = filepath.replace(sourcePath, outputPath);
      writeFile(filepath, strFileData);
    }
  }

  function vueparser(path, input) {
    var result = init$1(input);
    output(path, result);
  }

  function jsparser(path, input) {
    var result = rule$h(input);
    output(path, result);
  }

  function htmlparser(path, input, type) {
    var result;

    switch (type) {
      case 'vue':
        result = init(input, {
          tagRule: vueTagRule$1,
          textRule: vueTextRule$1
        });
        break;
    }

    output(path, ast2String(result));
  }

  return function (option) {
    extractOnly = option === null || option === void 0 ? void 0 : option.extractOnly;

    if (!outputPath) {
      outputPath = sourcePath;
    }

    if (!type) {
      type = "vue";
    }

    mapDirectory(sourcePath, function (path, extendsion, fileData) {
      try {
        switch (extendsion) {
          case 'vue':
            vueparser(path, fileData);
            break;

          case 'js':
            jsparser(path, fileData);
            break;

          case 'html':
            htmlparser(path, fileData, type);
            break;

          case 'java':
            break;
        }
      } catch (e) {
        console.error(e);
      }
    }, function () {
      option.extractCallback && option.extractCallback(wordMapping);
      writeFile(outputPath + "/words.json", JSON.stringify(wordMapping));
    });
  };
};

var index = {
  translate: translate
};

module.exports = index;
